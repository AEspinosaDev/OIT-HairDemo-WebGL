<!DOCTYPE html>
<!--
 ██╗    ██╗███████╗██╗ ██████╗ ██╗  ██╗████████╗███████╗██████╗     ██████╗ ██╗     ███████╗███╗   ██╗██████╗ ███████╗██████╗
██║    ██║██╔════╝██║██╔════╝ ██║  ██║╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗██║     ██╔════╝████╗  ██║██╔══██╗██╔════╝██╔══██╗
██║ █╗ ██║█████╗  ██║██║  ███╗███████║   ██║   █████╗  ██║  ██║    ██████╔╝██║     █████╗  ██╔██╗ ██║██║  ██║█████╗  ██║  ██║
██║███╗██║██╔══╝  ██║██║   ██║██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗██║     ██╔══╝  ██║╚██╗██║██║  ██║██╔══╝  ██║  ██║
╚███╔███╔╝███████╗██║╚██████╔╝██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝███████╗███████╗██║ ╚████║██████╔╝███████╗██████╔╝
 ╚══╝╚══╝ ╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═════╝

MADE BY

 ▄▀█ █▄░█ ▀█▀ █▀█ █▄░█ █ █▀█ █▀▀ █▀ █▀█ █ █▄░█ █▀█ █▀ ▄▀█
 █▀█ █░▀█ ░█░ █▄█ █░▀█ █ █▄█ ██▄ ▄█ █▀▀ █ █░▀█ █▄█ ▄█ █▀█
-->
<!--
    Based on "Weighted Blended Order-Independent Transparency"
    By Morgan McGuire and Louis Bavoil
    http://jcgt.org/published/0002/02/09/
-->
<html>
  <head>
    <title>Weighted OIT for HAIR</title>
    <meta charset="utf-8" />
    <script src="dependencies/gl-matrix.js"></script>
    <script src="node_modules/webgl-obj-loader/dist/webgl-obj-loader.js"></script>
    <script src="node_modules/dat.gui/build/dat.gui.js"></script>

    <link rel="stylesheet" href="css/style.css" />
  </head>

  <body>
    <canvas id="gl-canvas"></canvas>

    <!--
    ▄▀█ █▀▀ █▀▀ █░█ █▀▄▀█ █░█ █░░ ▄▀█ ▀█▀ █ █▀█ █▄░█
    █▀█ █▄▄ █▄▄ █▄█ █░▀░█ █▄█ █▄▄ █▀█ ░█░ █ █▄█ █░▀█
    -->
    <script type="x-shader/x-vertex" id="vertex-accum">
      #version 300 es

      layout(location=0) in vec3 position;
      layout(location=1) in vec2 uv;
      layout(location=2) in vec3 normal;

      layout(std140, column_major) uniform;
      uniform SceneUniforms {
          mat4 uProj;
          mat4 uView;
          mat4 uModelView;
          vec4 uEyePosition;
          vec4 uLightPosition;
      };
      uniform vec3 uHairColor;
      uniform float uHairOpacity;

      out vec3 vPosition;
      out vec2 vUV;
      out vec3 vNormal;
      out vec3 vLightPos;
      flat out vec4 vColor;

      void main() {

          vPosition = (uModelView * vec4(position,1.0)).xyz;
          vLightPos = (uView * vec4(uLightPosition.xyz,1.0)).xyz;
          vUV = uv;
          vNormal = mat3(transpose(inverse(uModelView))) * normal;

          vColor = vec4(uHairColor,uHairOpacity);
          //vColor = vec4(0.38*2.5,0.22*2.5,0.2*2.5,0.99); //GINGER
          //vColor = vec4(0.98,0.94,0.74,0.99); //BLONDE


          gl_Position =  uProj* uModelView *vec4(position,1.0);

      }
    </script>
    <script type="x-shader/x-fragment" id="fragment-accum">
      #version 300 es
      precision highp float;

      layout(std140, column_major) uniform;
      uniform SceneUniforms {
          mat4 uProj;
          mat4 uView;
          mat4 uModelView;
          vec4 uEyePosition;
          vec4 uLightPosition;
      };

      uniform sampler2D uTexture;

      in vec3 vPosition;
      in vec2 vUV;
      in vec3 vNormal;
      flat in vec4 vColor;
      in vec3 vLightPos;


      layout(location=0) out vec4 accumColor;
      layout(location=1) out float accumAlpha;


      vec3 phong(vec3 color){
        vec3 position = vPosition.xyz;
        vec3 normal = normalize(vNormal.xyz);

        vec3 eyeDirection = normalize(uEyePosition.xyz - position);
        vec3 lightVec = vLightPos.xyz - position;
        vec3 lightDirection = normalize(lightVec);
        vec3 reflectionDirection = reflect(-lightDirection, normal);

        float ambient = 0.2;
        float diffuse = max(dot(lightDirection, normal), 0.0);
        float specular = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 20.0);

        return vec3((ambient + diffuse + specular) * color.rgb);
      }


      float weight(float z, float a) {
          //
          //return clamp(pow(min(1.0, a * 10.0) + 0.01, 3.0) * 1e8 * pow(1.0 - z * 0.9, 3.0), 1e-2, 3e3);
          //float d = 1.0 - z * 0.99;
          //float d2 = d * d;
          //float d4 = d2 * d2;
          //float d8 = d4 * d4;
          //float d16 = d8 * d8;
          //float depthWeight = d + 10.0 * d2 + 1e2 * d4 + 1e5 * d16;
          //return clamp(a * depthWeight, 0.01, 1e4);

          //Maguire 2017 
          //https://casual-effects.com/research/McGuire2017Transparency/McGuire2017Transparency.pdf
          //float tmp = 10.0 * (1.0 - 0.99 * z) * a;
          //tmp *= tmp * tmp;
          //return clamp(tmp, 0.01, 30.0);
          //Modified twitter
          float tmp = 1.0 - z * 0.99;
                tmp *= tmp * tmp * 1e4;
                return clamp(a * tmp, 1e-3, 3e4);

          //return a*max(pow(10.0,-2.0),min(3000.0,0.03/(pow(10.0,-5.0)+pow((abs(z)/200.0),4.0)))); //EQUATION 9 ORIGINAL PAPER. GOOD FOR MIDDLE DISTANCES

      }

      void main() {

          vec2 uv = vUV;

          //PREMULTIPLY ALPHA
          vec4 baseColor = vColor * texture(uTexture, uv);
          //vec4 baseColor = vColor;
          vec4 color = vec4(phong(baseColor.rgb), texture(uTexture, uv).r*vColor.a);

          //???????
          //color.rgb *= color.a;

          float w = weight(gl_FragCoord.z, color.a);

          accumColor = vec4(color.rgb *  color.a, color.a)*w;//WITH PER RENDER TARGET BLENDING
          accumColor = vec4(color.rgb * w, color.a);//WITHOUT

          accumAlpha = color.a;//WITH PER RENDER TARGET BLENDING
          accumAlpha = color.a * w;//WITHOUT

      }
    </script>

    <!--
    █▀▀ █▀█ █▀▄▀█ █▀█ █▀█ █▀ █ ▀█▀ █ █▀█ █▄░█
    █▄▄ █▄█ █░▀░█ █▀▀ █▄█ ▄█ █ ░█░ █ █▄█ █░▀█
    -->
    <script type="x-shader/x-fragment" id="fragment-draw">
      #version 300 es
      precision highp float;

      uniform sampler2D uAccumulate;
      uniform sampler2D uAccumulateAlpha;

      out vec4 fragColor;

      void main() {
          ivec2 fragCoord = ivec2(gl_FragCoord.xy);

          vec4 accum = texelFetch(uAccumulate, fragCoord, 0);
          float r = accum.a;
          accum.a = texelFetch(uAccumulateAlpha, fragCoord, 0).r;
          fragColor = vec4(accum.rgb / clamp(accum.a, 0.001, 50000.0), r);

          //vec4 accum = texelFetch(uAccumulate, fragCoord, 0);
          //float a = 1.0 - accum.a;
          //accum.a = texelFetch(uAccumulateAlpha, fragCoord, 0).r;
          //fragColor = vec4(a * accum.rgb / clamp(accum.a, 0.001, 50000.0), a);
      }
    </script>

    <!--
    █▀█ █▀█ ▄▀█ █▀█ █░█ █▀▀
    █▄█ █▀▀ █▀█ ▀▀█ █▄█ ██▄
    -->

    <script type="x-shader/x-vertex" id="head_vert">
      #version 300 es

      layout(location=0) in vec3 position;
      layout(location=1) in vec2 uv;
      layout(location=2) in vec3 normal;


      layout(std140, column_major) uniform;

      uniform SceneUniforms {
          mat4 uProj;
          mat4 uView;
          mat4 uModelView;
          vec4 uEyePosition;
          vec4 uLightPosition;
      };
      uniform vec3 uColor;

      out vec3 vPosition;
      out vec2 vUV;
      out vec3 vNormal;
      out vec3 vLightPos;
      flat out vec4 vColor;

      void main() {
          vec4 pos = uModelView * vec4(position,1.0);
          vLightPos = (uView * vec4(uLightPosition.xyz,1.0)).xyz;
          vPosition = pos.xyz;
          vUV = uv;
          vNormal = mat3(transpose(inverse(uModelView))) * normal;
          //vColor = vec4(0.97,0.86,0.78,1.0);
          vColor = vec4(uColor,1.0);

          gl_Position =  uProj* uModelView *vec4(position,1.0);
      }
    </script>
    <script type="x-shader/x-fragment" id="head_frag">
      #version 300 es
      precision highp float;

      layout(std140, column_major) uniform;
      uniform SceneUniforms {
          mat4 uProj;
          mat4 uView;
          mat4 uModelView;
          vec4 uEyePosition;
          vec4 uLightPosition;
      };
      uniform sampler2D uTexture;

      in vec3 vPosition;
      in vec2 vUV;
      in vec3 vNormal;
      in vec3 vLightPos;
      flat in vec4 vColor;

      out vec4 fragColor;

      vec3 phong(vec3 color){
        vec3 position = vPosition.xyz;
        vec3 normal = normalize(vNormal.xyz);

        vec3 eyeDirection = normalize(uEyePosition.xyz - position);
        vec3 lightVec = vLightPos.xyz - position;
        vec3 lightDirection = normalize(lightVec);
        vec3 reflectionDirection = reflect(-lightDirection, normal);

        float ambient = 0.2;
        float diffuse = max(dot(lightDirection, normal), 0.0);
        float specular = 0.1 *pow(max(dot(reflectionDirection, eyeDirection), 0.0), 100.0);

        return vec3((ambient + diffuse + specular) * color.rgb);
      }

      void main() {

          //if(texture(uTexture,vUV).r < 0.01) discard;
          fragColor = vec4(phong(vColor.rgb),texture(uTexture,vUV).r);
          fragColor = vec4(phong(vColor.rgb),1.0);

      }
    </script>

    <script type="x-shader/x-vertex" id="vertex-quad">
      #version 300 es

      layout(location=0) in vec4 aPosition;

      void main() {
          gl_Position = aPosition;
      }
    </script>
    <script type="x-shader/x-fragment" id="screen-draw">
      #version 300 es
      precision highp float;


      uniform sampler2D screen;

      out vec4 fragColor;
      void main() {
          ivec2 fragCoord = ivec2(gl_FragCoord.xy);
          fragColor = vec4(texelFetch(screen, fragCoord,0).rgb, 1.0f);
          //Post-processing 
          //Gamma correction
          float gamma = 2.2;
          fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));
          

      }
    </script>
    

    <script type="module" src="main.js"></script>
  </body>
</html>
